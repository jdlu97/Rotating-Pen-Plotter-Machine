# Term Project: Plotting on a Pint Glass

This repository contains the source code and documentation for the term project for the Mechatronics course at California Polytechnic State University. Feel free to see the [source files](https://github.com/jdlu97/Rotating-Pen-Plotter-Machine/tree/main/src) and [documentation](https://jdlu97.github.io/Rotating-Pen-Plotter-Machine/) for more information.

 **Introduction**
 
 For this term project, we decided to create a pen plotter to draw on pint glasses. The purpose of this device is to add decoration to a glass, in the form of ink marks, and give it a sense of style or personality. We intended for this to be used by people who wanted to have a cool homemade design on their glasses or for low volume production of a fairly typical design. For our project, we made a star but this was only one design and could be adapted to make other designs as necessary.
 
 **Hardware Design Overview**
 
 We used several components from various sources to create our pen plotter. The first piece of our assembly was a ceramic wheel that had a stationary base and a rotating part that would spin about its axis. We hot glued a wooden gear to the top of this piece to allow for meshing with another same size gear on the base of our design. This gear then had 6 hot glue spots put on it to hold the glass in place while it was being inked. From there, we had a second wooden gear attached to a metal gear to our motor. Overall, the wooden gear meshed with the wooden gear on the ceramic wheel and allowed for rotation around the theta axis. Next for the r axis we have a lead screw that was angled to the same angle as our glass. This lead screw also had a carriage that was able to rotate which contained the Sharpie and solenoid that we used to create the device. This carriage would move up and down the lead screw in the r-direction allowing for different points to be inked. The solenoid was used to bring the Sharpie in and out to make the ink marks. This carriage sat in a wooden plate with an internal slot cut out of it. This constrained the motion of the carriage to only up and down and gave support to the whole system. Next on the top of the wooden piece connected to the lead screw was a bearing that would hold the lead screw in place during operation reducing vibration of the system and allow the system to move freely. Finally, the base was made out of 3D printed PLA that interfaced with the base of the ceramic wheel. The PLA base had a two holes cut out for the motors to fit into and allowed for the wooden board to be manually tilted at different angles. In addition, the motors/encoders were used from the lab.

 A CAD model of the project, which resembles its actual physical implementation is shown below.

 <p align="center">
    <img src="https://github.com/jdlu97/Rotating-Pen-Plotter-Machine/blob/main/img/assembly.png?raw=true" alt="CAD Model"/>
 </p>

 <p align="center">CAD model of the project</p><br/>

 **Software Overview**
 
 We used a series of tasks to allow our system to move. Our code had 4 tasks that worked in conjunction with a main file to create the desired motion. The 4 tasks were an two [encoder tasks](https://jdlu97.github.io/Rotating-Pen-Plotter-Machine/index.html#sec_enc) and two [controller tasks](https://jdlu97.github.io/Rotating-Pen-Plotter-Machine/index.html#sec_mot_ctrl). In addition, we used the cotask.py and task_share.py files to allow for multitasking and data sharing, respectively. The encoder and controller tasks created motion for both motors and encoders. These were used to asynchronously control the motors and allow for simultaneous motion in the system. 
 The setpoint values were the position coordinates of the image to be drawn. Image data extraction required some pre-processing. In short, we converted HPGL code into encoder ticks. To accomplish this, we opened an image in the Inkspace software and exported in HPGL format. We extracted the information of this file into a CSV file manually. For the presentation, we extracted x- and y-values of the image manually using Excel. However, we ultimately decided to automate this step and extract the x- (or theta-) and y-coordinates from the CSV file into the main script using code. This only requires having the CSV file of the image in the microcontroller. For more information about these tasks, visit the [documentation site](https://jdlu97.github.io/Rotating-Pen-Plotter-Machine/).
 
 **Results and Discussion**
 
 To validate the system, we performed several incremental tests. The first test was to see if our system was able to convert x and y coordinates into theta and r coordinates. After confirming that we were able to complete this step we used these coordinates to control two flywheels. We chose to use the flywheels to test as it was a piece of hardware we were familiar with and would allow us to verify that our controller, motors, and encoders, were all working together correctly. Next, we moved into testing the actual system. For this, we connected the motors to the hardware and then testing the system as a whole. The system performed well in the first two tests. We were easily able to convert over the data points and from there control the movement of two flywheels. However, once we moved into full system testing we found issues with our setpoints and gains. We found that for the theta position often the motor would have trouble reaching the final position due to stiction or it would oscillate around the final position because the gain was too high. We also burned out our solenoid during our final testing on the day of the presentation and had to quickly replace it with a working device. Therefore, while our system started out well, it was not until we integrated individual components into a single system that we noticed several underlying issues that were harder to address.
 
 **Concluding Remarks**
 
 Overall, the system performed well but there are, of course, things that could be improved. For a demo, the plotter system was supposed to create a star logo but it was only able to create half a star before turning the design into a series of lines. The inertia in the theta direction and a different solenoid that had less travel than the one we had been testing on, did not allow for the system to behave as expected. One of the major issues with the solenoid was the travel that we anticipated we could get out of it. However on the day of the presentation while testing we burned out our solenoid making it unfunctional. We had to quickly replace it with another solenoid but this one had less travel and thus did not interact with our system well. Thus we learned to keep a careful eye on the system to ensure that sensitive devices like that do not burn out. 
 
 The resolution of the gears that allowed theta positioning was very high and, thus, it was often hard to reach our final theta position goal since we only wanted to move a few encoder ticks. Onto of that due to the necessary hardware pieces to make it move out system contained a lot of inertia which caused our system to have high stiction. This caused issues as our motors would not be able to turn to the correct position and thus not be able to move on to the next setpoint. Through these two issues, we learned the importance of gearing and resolution. It did not occur to us that our resolution would be so low and thus would impact our ability to reach our specific setpoints while making the hardware, thus when we ran into this issue it was very difficult to try to think of a possible solution that would not reset us to square one. We also learned the importance of keeping the inertia low as our system would often drift and have to swing back after moving. This caused long lines on our final product thus reducing its effectiveness at creating a star. However, we found that our system did well in the r direction and was able to very easily hit the r direction set point every time. On top of that, the system was modular and would take any glass angle thus increasing its usefulness.